## Put comments here that give an overall description of what your
## functions do

## Two functions for creating and using a cache of inverted matrix objects.
## Purpose: avoid generating a matrix inverse if already done.
##
## makeCacheMatrix creates a wrapper we call CacheMatrix for the matrix function and a cache for inverse.
## The ordinary matrix generated by R's base function "matrix" is called a BaseMatrix here for clarify.
## cacheSolve is the wrapper. It is intended to function like the R base function "solve"
##   but with the added internal capability to save a generated inverse matrix.

# makeCacheMatrix Creates a CacheMatrix object
# Parameter x: an R basic matrix object
# Returns a CacheMatrix object
# CacheMatrix defines functions: set, get, setInverse, getInverse

makeCacheMatrix  <- function( contextBaseMatrix = matrix()) {
  cachedInverse <<- NULL # defined in the scope of this function

  set <- function(baseMatrix) {     #print("makeCacheMatrix set x to arg y, clear cache")
    contextBaseMatrix <<- baseMatrix
    cachedInverse <<- NULL # the "cache" is in the scope of the enclosing function, which doesn't go away after execution
  }
  get <- function() {     #print("get contextBaseMatrix, return contextBaseMatrix")
    contextBaseMatrix # in the scope of the enclosing function
  }
  setInverse <- function(inverseMatrix) {     #print("setInverse: cache the arg matrix")
    cachedInverse <<- inverseMatrix
  }
  getInverse <- function() {      #print("getInverse: return cached inverse")
    cachedInverse
  }
  
  wrapper <- list(set = set, get = get,
    setInverse = setInverse,
    getInverse = getInverse)
    #print("makeCacheMatrix returns wrapper")
  wrapper
}

## cacheSolve Produces the inverse of the BaseMatrix encapsulated in the given cachedInverseMatrix.
## Internally checks the cache for a saved inverse BaseMatrix and returns that if present.
## Otherwise generates an inverse of parameter BaseMatrix and saves it in the CacheMatrix object.
## paramter CacheMatrix must be an object created by function makeCacheMatrix
## Return a BaseMatrix that is the inverse of 'x'

cacheSolve <- function(CacheMatrix) {
  #print(" in cacheSolve")
  #print( cachedInverse)
  if(!is.null(cachedInverse)) {     #print("getting cachedInversed matrix")
    inverseBaseMatrix <- cachedInverse
  
  } else { 						    #print("computing inverse matrix")
    originalMatrix <- CacheMatrix$get()
    inverseBaseMatrix <- solve( originalMatrix)
    CacheMatrix$setInverse(inverseBaseMatrix)
  }
  inverseBaseMatrix
}

#################################################
# Unit Testing
# http://www.purplemath.com/modules/mtrxinvr2.htm

# cases, in this order: 
# 1 execute the two function definitions.
# 2 initial CacheMatrix object with an initial BaseMatrix
# 3 get BaseMatrix back
# 4 get inverse
# 5 get BaseMatrix back again
# 6 set a different BaseMatrix
# 7 get inverse
# 8 get BaseMatrix back
# 9 get inverse again and see that it is from the cache
# 10 create a different CacheMatrix (call it cmC here) object with a different BaseMatrix
# 11 verify that the first CacheMatrix's get and get are undamaged
# 12 set a different BaseMatrix in the first CacheMatrix
# 13 verify that the CacheMatrix cmC's get and get are undamaged
 
testCacheMatrix <- function() {
# sample matrix a
a <- matrix(  c( 1,0,5, 2,1,6, 3,4,0), nrow=3, ncol=3)
# expected inverse
aInvExpected <-  solve(a) ## matrix(  c(-24, 20, -5,  18,-15,4,  5,-4,1), nrow=3, ncol=3)
aInv <- NULL

# sample matrix b
b <- matrix( c(4,1,3,1), nrow=2, ncol=2)
bInvExpected <- solve(b)
bInv <- NULL
# sample matrix c
c <- rbind(c(1, -1/4), c(-1/4, 1)) 
cInvExpected <- solve(c)
cInv <- NULL


assertEq <- function(x, y, testCaseN="") {
	if (is.matrix(x) && is.matrix(y) && dim(x) == dim(y)) {
	  if (dim(x) == 1 && is.na(x[1,1] && is.na(y[1,1]))) {
		print( sprintf("Case %s PASS",testCaseN ))
	  } else if (all(round(x) == round(y))) {
		print( sprintf("Case %s PASS",testCaseN ))
	  } else {
		print( sprintf("Case %s FAIL !!!!", testCaseN))
	  }
	} else {
	  print( sprintf("Case %s FAIL !!!!", testCaseN))
	}
}

# implementation of the unit test sequence
# 1 execute the two function definitions and check default case. 
	# source this file
cm <- makeCacheMatrix( )
zeroDimMatrixInv <-  cacheSolve(cm)
   assertEq( matrix(), cm$getInverse(), 1)

# 2 initial CacheMatrix object with an initial BaseMatrix

cmA <- makeCacheMatrix( a)
  assertEq( a, a, 2)
	
# 3 get BaseMatrix back
  assertEq( a, cmA$get(), 3)
	
# 4 get inverse
  aInv <- cacheSolve( cmA)
  assertEq( aInvExpected, aInv, 4)
  

# 5 get BaseMatrix back again
  aUndamaged <- cmA$get()
  assertEq( a, aUndamaged, 5)


# 6 set a different BaseMatrix
  cmA$set( b)
  bGotBack <- cmA$get()
  assertEq( b, bGotBack, 6)
  

# 7 get inverse
  bInv <- cacheSolve(cmA)
  assertEq( bInvExpected, bInv, 7)


# 8 get BaseMatrix back
  bUndamaged <- cmA$get()
  assertEq( b, bUndamaged, 8)
  

# 9 get inverse again and see that it is from the cache
  bInv <- cacheSolve(cmA)
  assertEq( bInvExpected, bInv, 9)


# 10 create a different CacheMatrix (call it cmC here) object with a different BaseMatrix
  cmC <- makeCacheMatrix(c)
  cInv <- cacheSolve(cmC)
  assertEq( cInv, cInvExpected, 10)
  
## THIS CASE IS NOTE APPLICABLE: the cache is a singleton in the host environment  
# 11 verify that the first CacheMatrix's get and get are undamaged
  #assertEq( cmA$get(), b, 11)
  #assertEq( cacheSolve(cmA), bInvExpected, 11)


# 12 set a different BaseMatrix in the first CacheMatrix
  cmA$set(a)
  assertEq( cmA$get(), a, 12)
  
  
# 13 verify that the CacheMatrix cmC's get and get are undamaged
  assertEq( cmC$get(), c, 13)
  assertEq( cacheSolve(cmC), c, 13)
  #assertEq( cacheSolve(cmA), aInvExpected, 13) ## not applicable
}
